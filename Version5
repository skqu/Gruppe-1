import tkinter as tk
from tkinter import ttk
import tkinter.filedialog
from math import sqrt
from graphics import *
import re
import json
import os
import csv
import xml.etree.ElementTree as ET
import xml.dom.minidom
import base64
import datetime

from graphics import Point, Text
import time



class Calculator():
    def __init__(self) -> None:
        Gui()
    
    def calculate(self, input):
        try: 
            return str(eval(input))
        except:
            print("exeption")

class Gui(Calculator):
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Calculator")
        self.handler = Handler(JsonFileManager())  # Pass JsonFileManager instance to Handler
        self.buildLayout()
        self.style()
        self.root.mainloop()
        
    def stop_application(self):
        self.root.destroy()  # Close the Tkinter window

    def buildLayout(self):

        # DISPLAY

        self.display = tk.Label(self.root, text = "0", font=("Arial", 32), anchor="e", justify="right", width=12)
        self.display.pack()


        self.display.pack(padx=10, pady=10)
        self.display.focus_set()

        # Frame for numbers and operators
        self.numpad_frame = tk.Frame(self.root)
        self.numpad_frame.pack()
        
        
        
        #Numpad
        self.list_buttons = [
            "(", ")", "C", "\u2190",
            "\u221A", "x^2", "x^x", "/",
            "7", "8", "9", "*",
            "4", "5", "6", "-",
            "1", "2", "3", "+",
            "+/-", "0", ".", "="
        ]

        self.buildButtons(self.list_buttons, self.numpad_frame, 4) 


    def buildButtons(self, list_buttons, frame, maxCol = 1): #Create buttons for a frame 
        row = 0
        col = 0

        for button_text in list_buttons:
            button = tk.Button(frame, text=button_text, font=("Arial", 16), width=6, height=2, borderwidth=0)
            button.grid(row=row, column=col, padx=2, pady=2)
            button.bind("<Button-1>", self.events)
            col += 1
            if col == maxCol:
                col = 0
                row += 1
    
    def displayText(self, text):
        

        if len(self.display.cget("text")) == 0:
            newText = 0
        
        else:
                
            if self.display.cget("text") == "0":
                newText = text
             
            else:
                newText = self.display.cget("text") + text
             
                    
        self.display.config(text = newText)
     
    

    def events(self, event): #Button events
        newText = ""
        text = event.widget.cget("text")
        self.display.focus_set()
        
        

        match text:
            case "=":
                new = self.display.cget("text").replace('\u221A', 'sqrt')
                new = new.replace('^', '**')

                newText = self.calculate(new)
                self.display.config(text = newText)
                #print("testA",newText, new)
                self.handler.save_result(newText, new)
                self.handler.display_results()
              
            case "C":
                self.display.config(text = "0")
                

            case "\u2190": #Backspace

                newText = self.display.cget("text")[:-1]
                self.display.config(text = newText)
                if len(self.display.cget("text")) == 0:
                    self.display.config(text = "0")
                   
            case "+/-":
                if self.display.cget("text")[0] != "-":
                    newText = "-" + self.display.cget("text")
                    
                else:
                    newText = self.display.cget("text")[1:]
                    

                self.display.config(text = newText)
                
            case "\u221A": #Squareroot
                newText = text + "("
                self.displayText(newText)
               
            
            case "x^2": 
                newText = "^2"
                self.displayText(newText)
                

            case "x^x":
                print("SAdasdsdsd")
                newText = "^"
                self.displayText(newText)
                
            
            case _:
                newText = text
                self.displayText(newText)
               

    def styleChildren(self, widget, bg_color, text_color):
        widget.configure(bg=bg_color)
        if isinstance(widget, (tk.Label, tk.Button)):
            widget.configure(fg=text_color)
        if isinstance(widget, tk.Frame):
            for child in widget.winfo_children():
                self.styleChildren(child, bg_color, text_color)
                    

    def style(self):

        backgroundColor = "#262626"
        fontColor = "#ffffff"

        self.styleChildren(self.numpad_frame, "#3d3d3d", fontColor)

        self.root.config(background = backgroundColor)
        self.display.config(background = backgroundColor)
        self.numpad_frame.config(background = backgroundColor)
        self.display.config(fg = fontColor)
        
  
        
class Handler():
       
    def __init__(self, json_manager):
        self.result_list = []
        self.json_manager = json_manager
        self.csv_manager = CsvFileManager()
        self.xml_manager = XmlFileManager()

      
    def save_result(self, newText, new):
        # Save the result in the list
        self.result_list.append((newText, new))

        # Keep only the last 10 results
        if len(self.result_list) > 10:
            self.result_list = self.result_list[-10:]

        # Save all results to JSON, CSV, and XML
        results_to_save = [
            (result_text, result_data)
            for result_text, result_data in self.result_list
        ]

        # Save to JSON
        for result_text, result_data in results_to_save:
            self.json_manager.add_data(result_text, result_data)

        # Save to CSV
            self.csv_manager.save_to_csv("CSVresults.csv", results_to_save)

        # Save to XML
            self.xml_manager.save_to_xml(results_to_save)

        print("test3")
            
    def display_results(self):
        print("Results:")
        # Display up to the last 10 results
        for i, result_pair in enumerate(reversed(self.result_list)):
            # Display results in reverse order (latest calculation first)
            print(f"{i + 1}. {result_pair[0]} = {result_pair[1]}")

            
class JsonFileManager:
    def __init__(self, filename="jSontest", initial_data=None):
        self.filename = filename
        self.data = initial_data or {}
        self.load_data()

    def load_data(self):
        try:
            with open(self.filename, "r") as file:
                self.data = json.load(file)
        except FileNotFoundError:
            # Handle the case where the file doesn't exist
            self.save_data()

    def save_data(self):
        with open(self.filename, "w") as file:
            json.dump(self.data, file, indent=2)
    def add_data(self, key, value):
        self.load_data()
        # Update the existing data or add a new key-value pair
        self.data[key] = value
        # Save the updated data
        self.save_data()

    def get_all_data(self):
        # Load existing data
        self.load_data()
        return self.data

    def get_all_data(self):
        return self.data
class CsvFileManager:
     def save_to_csv(self, filename, data):
       try:
           with open(filename, mode='w', newline='') as file:
               writer = csv.writer(file)
               # Write header
               writer.writerow(["Value","Expression"])
                #Write data
               writer.writerows(data)
       except Exception as e:
           print(f"Error saving to CSV: {e}")


class XmlFileManager:
    def __init__(self, xml_filename="XMLresults.xml"):
        self.filename = xml_filename
        self.xml_filename = xml_filename
        self.data = []
        self.load_xml_data()
        
        
    def save_to_xml(self, data):
        try:
            root_xml = ET.Element("XMLresults")
            for result in data:
                item = ET.SubElement(root_xml, "Result")
                key, value = result
                ET.SubElement(item, "Expression").text = str(key)
                ET.SubElement(item, "Value").text = str(value)

            tree = ET.ElementTree(root_xml)
            tree.write(self.xml_filename)

        except Exception as e:
            print(f"Error saving to XML: {e}")


    def load_xml_data(self):
        try:
            # Load and display XML data
            tree_xml = ET.parse(self.xml_filename)
            root_xml = tree_xml.getroot()
            for item in root_xml.findall('Result'):
                expression = item.find('Expression').text
                value = item.find('Value').text
                self.data.append((expression, value))
        except FileNotFoundError:
            print(f"File not found.")
        except Exception as e:
            print(f"Error: {e}")

    def display_xml_data(self):
        root_xml_display = tk.Tk()
        root_xml_display.title("XML Historik")

        # Create a treeview widget
        tree = ttk.Treeview(root_xml_display, columns=("Expression", "Value"))
        tree.heading("#0", text="XML Results")
        tree.heading("Expression", text="Expression")
        tree.heading("Value", text="Value")

        tree.pack(expand=True, fill="both")

        # Update the treeview with loaded data
        for i, (expression, value) in enumerate(self.data):
            tree.insert("", i, values=(expression, value), text=f"Row {i + 1}")

        root_xml_display.mainloop()


class FileDisplayHandlerXML:
    def __init__(self, master, file_type='xml'):
        self.master = master
        self.master.title("File Display")
        self.frame = ttk.Frame(master)
        self.frame.grid(row=0, column=0, sticky="nsew")

        # Create a treeview widget
        self.tree = ttk.Treeview(self.frame, columns=("Value","Expression"))
        self.tree.heading("#0", text="XML-File")
        self.tree.heading("Expression", text="Expression")
        self.tree.heading("Value", text="Value")
        self.tree.grid(row=0, column=0, sticky="nsew")

        # Buttons to load and display files
        self.load_button = ttk.Button(self.frame, text="Load XML Data", command=self.load_file)
        self.load_button.grid(row=1, column=0, padx=5, pady=5)

        # self.display_button = ttk.Button(self.frame, text="Display File", command=self.display_file)
        # self.display_button.grid(row=1, column=1, padx=5, pady=5)

        # Variable to store loaded file data
        self.file_data = None
        self.file_type = file_type

    def load_file(self):
        file_path = "XMLresults.xml"  # Assuming the file is in the root directory
        if self.file_type == "xml" and file_path:
            self.file_data = self.load_xml(file_path)
            # Update the treeview with loaded data
            self.update_treeview()

    def load_xml(self, file_path):
        tree = ET.parse(file_path)
        root = tree.getroot()
        data = []
        for item in root.findall("Result"):
            expression = item.find("Expression").text
            value = item.find("Value").text
            data.append((expression, value))
        return data

    def update_treeview(self):
        # Clear existing items in the treeview
        for item in self.tree.get_children():
            self.tree.delete(item)

        if self.file_data:
            if isinstance(self.file_data, list):
                for i, (expression, value) in enumerate(self.file_data):
                    self.tree.insert("", i, values=(expression, value), text=f"Row {i+1}")
            elif isinstance(self.file_data, dict):
                header = self.file_data.get("header", [])
                data = self.file_data.get("data", [])

                # Insert header
                self.tree.insert("", 0, values=header, text="Header")

                # Insert data rows
                for i, row in enumerate(data):
                    self.tree.insert("", i + 1, values=row, text=f"Row {i + 1}")

    def display_file(self):
        # Implement your logic for displaying the selected file (not provided in this example)
        pass


class DisplayFrameJson:
    def __init__(self, filename="jSontest"):
        self.win = GraphWin(filename, 400, 600)
        self.filename = filename
        self.data = self.load_data()
        self.y_coordinate = 30  # Start y-coordinate

    def load_data(self):
        try:
            with open(self.filename, "r") as file:
                data = json.load(file)
                return data
        except FileNotFoundError:
            print(f"File {self.filename} not found.")
            return {}
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON in file {self.filename}: {e}")
            return {}

    def display_data(self):
 #       y_coordinate = 30  # Start y-coordinate
        for key, value in self.data.items():
            if isinstance(value, dict):  # If value is a dictionary, it's a nested result
                for inner_key, inner_value in value.items():
                    text = Text(Point(200, self.y_coordinate), f"{inner_key}: {inner_value}")
                    text.draw(self.win)
                    self.y_coordinate += 30  # Increment y-coordinate
            else:
                text = Text(Point(200, self.y_coordinate), f"{key}: {value}")
                text.draw(self.win)
                self.y_coordinate += 30  # Increment y-coordinate
    

class CSVDisplayHandler:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("CSV Display")

        self.frame = ttk.Frame(self.root)
        self.frame.grid(row=0, column=0, sticky="nsew")

        # Create a treeview widget
        self.tree = ttk.Treeview(self.frame, columns=("Column1", "Column2"))
        self.tree.heading("#0", text="File")
        self.tree.heading("Column1", text="Column1")
        self.tree.heading("Column2", text="Column2")
        self.tree.grid(row=0, column=0, sticky="nsew")

        # Button to display CSV data
        self.display_button = ttk.Button(self.frame, text="Load CSV Data", command=self.display_csv_data)
        self.display_button.grid(row=1, column=0, pady=5)

        # Variable to store loaded CSV data
        self.csv_data = None

    def display_csv_data(self):
        file_path = "CSVresults.csv"  # Assuming the file is in the root directory
        if file_path:
            self.csv_data = self.load_csv(file_path)
            # Update the treeview with loaded data
            self.update_treeview()

    def load_csv(self, file_path):
        with open(file_path, "r") as file:
            reader = csv.reader(file)
            header = next(reader)
            data = [row for row in reader]
        return {"header": header, "data": data}

    def update_treeview(self):
        # Clear existing items in the treeview
        for item in self.tree.get_children():
            self.tree.delete(item)

        if self.csv_data:
            header = self.csv_data["header"]
            data = self.csv_data["data"]

            # Insert header
            self.tree.insert("", 0, values=header, text="Header")

            # Insert data rows
            for i, row in enumerate(data):
                self.tree.insert("", i + 1, values=row, text=f"Row {i + 1}")

    def run(self):
        self.root.mainloop()



class Graphics_Start:
    def __init__(self, root):
        self.root = root
        root.title("Start Calculator")
        self.result_var = tk.StringVar()
        self.result_var.set("0")
        
        # Create calculator buttons
        buttons = [
            'Start Lommeregner',
            'Afslut Lommeregner',
            'jSon', 'XML', 'CSV', 'SQL'
        ]

        row, col = 1, 0
        for button in buttons:
            tk.Button(root, text=button, command=lambda b=button: self.on_button_click(b), padx=30, pady=20, font=("Arial", 20)).grid(row=row, column=col)
            col += 1
            if col > 3:
                col = 0
                row += 1

    def on_button_click(self, button):
        if button == 'Start Lommeregner':
            self.GG=Gui()
        elif button == 'Afslut Lommeregner':
            self.GG.stop_application()
            
        elif button == 'List':
            self.result_var.set("0")
        elif button == 'jSon':
            # # Create an instance of DisplayFrame
            display_frame = DisplayFrameJson()# Display JSON data
            display_frame.display_data()
        elif button == 'XML':
            app = FileDisplayHandlerXML(self.root, file_type='xml')
        elif button == 'CSV':
            csv_display_handler = CSVDisplayHandler()
            csv_display_handler.run()
        elif button == 'SQL':
            self.result_var.set("0")

        

  

class Main:
    def __init__(self):
        self.root = tk.Tk()
        self.graphics = Graphics_Start(self.root)
        self.root.mainloop()

if __name__ == "__main__":
    main_app = Main()
